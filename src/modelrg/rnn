
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

pip install sgt
import sgt

from statsmodels.compat import lzip
import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose
import statsmodels.graphics.tsaplots as sgt
from statsmodels.tsa.stattools import adfuller, kpss

from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import r2_score

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN
from tensorflow.keras.layers import Dense

import wandb
wandb.login()



# Dividir en conjuntos de entrenamiento, validación y prueba
train_size = int(len(data) * 0.7)
val_size = int(len(data) * 0.15)
test_size = int(len(data)) - train_size - val_size

train_data, val_data, test_data = data[:train_size], data[train_size:train_size+val_size], data[train_size+val_size:]

def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data)-seq_length):
        X.append(data.iloc[i:i+seq_length].values) # Use iloc to access rows by position
        y.append(data.iloc[i+seq_length].values) # Use iloc to access rows by position
    return np.array(X), np.array(y)

# Definir la longitud de la secuencia
seq_length = 5

# Crear secuencias de entrenamiento
X_train, y_train = create_sequences(train_data, seq_length)
X_val, y_val = create_sequences(val_data, seq_length)
X_test, y_test = create_sequences(test_data, seq_length)

# Imprimir las formas de los conjuntos de datos de entrenamiento, validación y prueba
print("Forma de X_train:", X_train.shape)
print("Forma de y_train:", y_train.shape)
print("Forma de X_val:", X_val.shape)
print("Forma de y_val:", y_val.shape)
print("Forma de X_test:", X_test.shape)
print("Forma de y_test:", y_test.shape)


# Definir el modelo de RNN
model_rnn = Sequential([
    SimpleRNN(10, input_shape=(seq_length, 1)),
    Dense(1)
])

# Compilar el modelo
model_rnn.compile(optimizer='adam', loss='mean_squared_error')

# Entrenar el modelo
history_rnn = model_rnn.fit(X_train, y_train, epochs=30, batch_size=8, verbose=1, validation_data=(X_val, y_val))


# Realizar predicciones
train_predictions_rnn = model_rnn.predict(X_train)
val_predictions_rnn = model_rnn.predict(X_val)
test_predictions_rnn = model_rnn.predict(X_test)



run = wandb.init(project='Integradorpj-2024', name="rnn")

wandb.sklearn.plot_residuals(reg, X_train, y_train)

wandb.sklearn.plot_outlier_candidates(reg, X_train, y_train)

wandb.sklearn.plot_regressor(reg, X_train, X_test, y_train, y_test, model_name='Ridge')

wandb.finish()
